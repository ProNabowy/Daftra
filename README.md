# Pokémon Browser

## 1. Project Overview

Pokémon Browser is a responsive Pokédex built with **React 18**, **TypeScript**, and **Vite**, styled with **Tailwind CSS** and a few utility classes in `App.css`. It consumes the public [PokeAPI](https://pokeapi.co/) and demonstrates two complementary collection browsing strategies (classic pagination and infinite “load more”), along with a richly detailed Pokémon profile view. Data fetching, caching, and background updates are powered by **@tanstack/react-query**, while client-side navigation uses **react-router-dom**.

Implemented capabilities include:

- Paginated listing view with numbered navigation, ellipsis logic, and automatic scroll-to-top behaviour.
- Infinite scrolling experience powered by a “Load More” button that streams pages via `useInfiniteQuery`.
- Dedicated Pokémon detail screen that surfaces stats, abilities, types, experience, responsive layouts, and sprite imagery.
- Skeleton placeholders, spinners, and friendly error states with retry controls across all routes.
- Image fallback logic to keep the UI polished even when sprites fail to load.

## 2. Live Demo & Repository Links

| Resource          | URL                                                                     |
| ----------------- | ----------------------------------------------------------------------- |
| Live Demo         | `https://daftra-two.vercel.app/` [VISIT] https://daftra-two.vercel.app/ |
| GitHub Repository | `https://github.com/ProNabowy/Daftra`                                   |

## 3. Features (Detailed)

- **Pagination view** – `PaginationView` shows 20 Pokémon per page, featuring numbered navigation generated by `usePaginationControls`, smooth scrolling to the top, and Tailwind grid layouts that adapt to each breakpoint.
- **Load More view** – `LoadMoreView` batches infinite pages via `useInfiniteQuery`, dedupes Pokémon IDs, and exposes a progress spinner plus disabled state while fetching the next batch.
- **Pokémon detail page** – The `/pokemon/:id` route renders modular sections (header, sprite, stats, abilities, experience, info cards) assembled from dedicated components under `components/pokemon`.
- **Loading states** – `PokemonCardSkeleton`, `PokemonDetailSkeleton`, and inline spinners create a consistent skeleton-first experience for both list and detail routes.
- **Error states with retry** – `ErrorMessage` centralizes messaging, contextual copy, and retry callbacks supplied by React Query’s `refetch`.
- **Responsive layout behaviour** – Tailwind utility classes such as `grid-cols-2 sm:grid-cols-3 ...` and mobile-first detail layouts keep the UI touch-friendly on phones, tablets, and desktops.
- **Image fallback handling** – `ImageWithFallback` displays pulse placeholders, handles sprite load failures, and swaps to an accessible SVG icon if the original asset cannot be retrieved.
- **Extra platform features** – React Query caching & background refresh, route-based code organization via `AppRouter`, reusable hooks (`usePaginationView`, `useLoadMoreView`, `usePokemonDetail`), and reusable UI primitives (Loader, BackButton, TypeBadge, etc.).

## 4. Folder Structure

```
src/
  assets/                # Static icons, illustrations, or branding assets
  components/
    layout/              # Global compositional pieces like the header
    pokemon/             # Domain-specific cards, detail sections, badges
    ui/                  # Reusable UI primitives (Loader, ErrorMessage, etc.)
  hooks/                 # View-specific logic composed as reusable hooks
  layouts/               # Layout wrappers (e.g., MainLayout)
  pages/                 # Route-level views (Pagination, Load More, Detail)
  router/                # Centralized route definitions (AppRouter)
  services/
    api/                 # REST clients for the PokeAPI
  types/                 # Shared TypeScript interfaces for API responses & props
  utils/                 # Formatters, Pokémon helpers, and generic utilities
  App.tsx                # React Query + Router providers and root component
  main.tsx               # React DOM bootstrap and strict mode wrapper
  index.css / App.css    # Tailwind setup plus global tweaks
```

### Folder Responsibilities

- `components/` – Presentation-layer building blocks split by domain (`pokemon/`) and generic UI (`ui/`), promoting reusability across pages.
- `hooks/` – Encapsulate data fetching, navigation, and UI coordination logic so components stay declarative and test-friendly.
- `pages/` – View models that orchestrate hooks and components for each route; maps 1:1 with router entries.
- `router/` – Defines top-level SPA routes and wraps them with `MainLayout`.
- `services/api/` – Performs fetch calls to PokeAPI; the single source of truth for network requests.
- `types/` – Centralizes TypeScript contracts to keep API usage consistent.
- `utils/` – Pure helper utilities (`extractPokemonId`, `getPokemonSpriteUrl`, formatting helpers).
- `assets/` – Placeholder home for future logos, sprites, or illustration files.

## 5. How to Install & Run

```bash
git clone <repo>
cd <project>
npm install
npm run dev      # start Vite on http://localhost:3000 (default)
npm run build    # type-check + bundle production assets
npm run preview  # serve production build locally
```

## 6. Environment Variables

```bash
VITE_APP_BASE_URL=https://pokeapi.co/api/v2
```

Place variables in a `.env` (or `.env.local`) file at the project root. Vite inlines variables prefixed with `VITE_` and exposes them through `import.meta.env`, e.g. `const baseUrl = import.meta.env.VITE_APP_BASE_URL;`. Swap the default constant inside `services/api/index.ts` with this value if you need to point at a proxy or mock server.

## 7. Architecture & Code Quality Notes

- **Modular structure** – UI, hooks, services, and utilities are split into focused folders, reducing coupling.
- **Separation of concerns** – Hooks manage state and data access, components remain stateless/presentational, and services own the fetch logic.
- **Testability-friendly** – Most hooks depend on injected navigation/query APIs, enabling mocking; pure functions live in `utils/` for straightforward unit testing.
- **Reusable hooks** – `usePaginationView`, `useLoadMoreView`, and `usePokemonDetail` encapsulate pagination math, infinite query orchestration, and detail fetching.
- **Reusable UI components** – Skeletons, loaders, message banners, and buttons keep UX patterns consistent and easy to audit.

## 8. Responsiveness Notes

- **Grid breakpoints** – Tailwind utilities (`grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6`) keep card density appropriate for each screen width.
- **Layout adaptation** – The detail page swaps between stacked sections on mobile and a two-column grid on medium+ screens, minimizing horizontal scrolling.
- **Touch improvements** – Global CSS sets `touch-action: manipulation` on buttons/links, hit areas are generously padded, and scroll locking prevents accidental sideways scrolling.

## 9. Loading & Error State Logic

- **Skeletons** – Initial loads render `PokemonCardSkeleton` grids, while detail pages mount `PokemonDetailSkeleton` to preserve layout height and avoid content shifting.
- **Spinners** – Infinite loading uses a Tailwind-powered spinner between pages, signalling background fetch progress without blocking interaction.
- **Error messages & retry** – `ErrorMessage` displays contextual copy plus a retry button wired to each hook’s `refetch` handler; early failures short-circuit the page while incremental failures show inline alerts.
- **Image fallback** – `ImageWithFallback` shows a pulsing placeholder while sprites load, switches to an accessible SVG illustration when `onError` fires, and ensures the layout remains stable.

## 10. Deployment Instructions

- **Vercel**
  1. Import the repository in Vercel and select the Vite preset.
  2. Set optional env vars (`VITE_APP_BASE_URL`) through Project Settings → Environment Variables.
  3. Build command: `npm run build`; Output directory: `dist`.
  4. Deploy — Vercel automatically configures SPA routing.
- **Netlify**
  1. `netlify init` or connect the repo via the Netlify UI.
  2. Build command: `npm run build`; Publish directory: `dist`.
  3. Add `_redirects` with `/* /index.html 200` or configure “Redirects → SPA fallback” so client-side routes resolve correctly.
- **Cloudflare Pages**
  1. Create a new Pages project and link the repo.
  2. Set the build command to `npm run build` and output to `dist`.
  3. Enable “Single-page app mode” (or add a `[[redirects]]` rule) to route all paths to `index.html`.

## 11. What Could Be Improved

- Add automated tests (component/unit/e2e) for hooks, services, and critical UI flows.
- Enhance UI polish with motion, theming, or accessibility refinements (dark mode, keyboard traps, focus outlines).
- Introduce a lightweight global state layer for user preferences (view mode, filters) that persists between sessions.
- Cache supplementary data (species info, evolution chain) and surface richer insights on the detail page.
- Implement server-side rendering or pre-rendering for faster first paint and SEO benefits.
